// Generated by CoffeeScript 1.8.0
(function() {
  var DEBUG, GRP_LIST, Sudoku, check, debug_log, _g, _gx, _gy, _i, _x, _y;

  DEBUG = false;

  debug_log = function(s) {
    if (DEBUG === true) {
      return console.log(s);
    }
  };

  _i = function(x, y) {
    return x + y * 9;
  };

  _x = function(i) {
    return i % 9;
  };

  _y = function(i) {
    return Math.floor(i / 9);
  };

  _gx = function(i) {
    var x;
    x = _x(i);
    return Math.floor(x / 3) * 3;
  };

  _gy = function(i) {
    var y;
    y = _y(i);
    return Math.floor(y / 3) * 3;
  };

  GRP_LIST = [0, 1, 2, 9, 10, 11, 18, 19, 20];

  _g = function(gi, n) {
    return gi + GRP_LIST[n];
  };

  check = function(cur, val, q, a) {
    var gi, gx, gy, i, ids, j, v, x, y, _j, _k, _len;
    x = _x(cur);
    y = _y(cur);
    gx = _gx(cur);
    gy = _gy(cur);
    gi = _i(gx, gy);
    for (j = _j = 0; _j <= 8; j = ++_j) {
      ids = [_i(j, y), _i(x, j), _g(gi, j)];
      for (_k = 0, _len = ids.length; _k < _len; _k++) {
        i = ids[_k];
        if (i === cur) {
          continue;
        }
        v = q[i];
        if (q[i] === 0) {
          v = a[i];
        }
        if (v === val) {
          return false;
        }
      }
    }
    return true;
  };

  Sudoku = (function() {
    function Sudoku() {}

    Sudoku.empty = 0;

    Sudoku.beautify = function(q) {
      var i, s, _j;
      if (q.length === 0) {
        return "";
      }
      s = '';
      for (i = _j = 0; _j <= 80; i = ++_j) {
        if (q[i] === 0) {
          s += '_';
        } else {
          s += '' + q[i];
        }
        if ((_x(i)) === 8) {
          s += "\n";
        } else {
          s += ",";
        }
      }
      return s;
    };

    Sudoku.prettify = function(q) {
      return this.beautify(q);
    };

    Sudoku.solve = function(q) {
      var ans, count, cur, i, ret, val, _j;
      ans = [];
      cur = 0;
      val = 1;
      count = 0;
      while (true) {
        count++;
        if (val > 9) {
          ans[cur] = 0;
          while (true) {
            cur--;
            if (cur < 0 || q[cur] === 0) {
              break;
            }
          }
          if (cur < 0) {
            debug_log("failed");
            return [];
          } else {
            val = ans[cur] + 1;
            ans[cur] = 0;
            debug_log("---> backtrack to (" + (_x(cur)) + "," + (_y(cur)) + ")");
            continue;
          }
        } else if (cur > 80) {
          ret = [];
          for (i = _j = 0; _j <= 81; i = ++_j) {
            if (q[i] === 0) {
              ret[i] = ans[i];
            } else {
              ret[i] = q[i];
            }
          }
          console.log("count: " + count);
          return ret;
        } else {
          if (check(cur, val, q, ans)) {
            debug_log("[PUT] " + val + " on (" + (_x(cur)) + "," + (_y(cur)) + ")");
            ans[cur] = val;
            val = 1;
            while (true) {
              cur++;
              if (cur > 80 || q[cur] === 0) {
                break;
              }
            }
            debug_log("---> move to (" + (_x(cur)) + "," + (_y(cur)) + ")");
            continue;
          } else {
            val++;
            continue;
          }
        }
      }
    };

    return Sudoku;

  })();

  this.Sudoku = Sudoku;

}).call(this);
